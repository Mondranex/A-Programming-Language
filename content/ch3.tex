
\chapter{Representation of Variables}

\section{Allocation and encoding}

\par Although the abstract description of a program may be presented in any suitable language, its automatic execution must be performed on some specified representation of the relevant operands. The specification of this representation presents two distinct aspects---allocation and encoding.

\par An \textit{allocation} specifies the correspondences between physical devices and the variables represented thereby. An \textit{encoding} specifies the correspondences between the distinct states of the physical devices and the literals which they represent. If, for example, certain numerical data are to be represented by a set of 50 two-state devices, the two-out-of-five coding system of Exercise 1.6 might be chosen, and it would then remain to specify the allocation. The two-digit quantity ``hours worked'' might be allocated as follows: devices 31-35 represent components 1-5, respectively, of the first digit, and devices 29, 16, 17, 24, and 47 represent components 1, 2, 3, 4, 5, respectively, of the second digit.

\par The encoding of a variable will be specified by an \textit{encoding matrix} $\mat{C}$ and associated \textit{format vector} $\vect{f}$ such that the rows of $\overline{\vect{f}}/\mat{C}$ list the representands and the rows of $\vect{f}/\mat{C}$ list the corresponding representations. The encoding is normally fixed and normally concerns the programmer only in the translation of input or output data. Even this translation is usually handled in a routine manner, and attention will therefore be restricted primarily to the problem of allocation.

\par However, the encoding of numeric quantities warrants special comment. It includes the representation of the sign and of the scale, as well as the representation of the significant digits. Small numbers, such as indices, admit not only of the usual positional representation but also of the use of the unit vector $\symbfup{\epsilon}^j$ to represent the number $j$ (i.e., a one-out-of-$n$ coding system), or of the use of a logical vector of weight $j$ (i.e., a base 1 number system).

\par Allocation will be described in terms of the \textit{physical vector} $\vect{\pi}$, which denotes the physical storage elements of the computer. Each component of $\vect{\pi}$ corresponds to one of the $\nu(\vect{\pi})$ similar physical devices available, its range of values is the set of physical states achievable by each device, and its index is the address of the device. Each component of $\vect{\pi}$ may correspond to a computer register, an individual character position in a register, or an individual binary digit within a character, depending on the degree of resolution appropriate to the allocation problem considered. The 0-origin indexing normally used for computer addresses will be used for the physical vector, but 1-origin indexing will, throughout this chapter, normally be employed for all other structured operands.

\par An index of the physical vector will be called an \textit{address} and will itself be represented in the (perhaps mixed) radix appropriate to the given computer. The Univac, for example, employs base ten addressing for the registers, and (because of the use of 12-character words) a radix of twelve for finer resolution. The address of the fourth character of register 675 might therefore be written as 675.3. In computers which have two or more independent addressing systems (e.g., the independent addressing systems for main memory and for auxiliary storage in the IBM 705), superscripts may be used to identify the several physical vectors $\vect{\pi}^j$.

\par In general, the \textit{representation} of a quantity $x$ is a vector (to be denoted by $\vect{⍴}(x)$) whose components are chosen from the physical vector $\vect{\pi}$. Thus $\vect{⍴}(x) = \vect{k}\int\vect{\pi}$, where $\vect{k}$ is a mapping vector associated with $x$. The dimension of the representation (that is, $\nu(\vect{⍴}(x))$) is called the \textit{dimension of} $x$ \textit{in} $\vect{\pi}$. If, for example, $\vect{⍴}(x) = (\vect{\pi}_{10}, \vect{\pi}_{9}, \vect{\pi}_{17}, \vect{\pi}_{18})$, then $\vect{k} = (10, 9, 17, 18)$, and the dimension of $x$ in $\vect{\pi}$ is four. If $\vect{⍴}(x)$ is an infix of $\vect{\pi}$, then the representation of $x$ is said to be \textit{solid}. A solid representation can be characterized by two parameters, its dimension $d$ and its \textit{leading address} $f$, that is, the index in $\vect{\pi}$ of its first component. Then $\vect{⍴}(x) = (f ↓ \vect{⍺}^d)/\vect{\pi}$.


\section{Representation of structured operands}

\subsection*{The grid matrix}

\par If each component of a vector $\vect{x}$ has a solid representation, then the representation of the entire vector is said to be solid and may be characterized by the \textit{grid matrix} $\tree{\Gamma}(\vect{x})$, of dimension $\nu(\vect{x}) \times 2$, defined as follows: $\tree{\Gamma}_1^i(\vect{x})$ is the leading address of $\vect{⍴}(\vect{x}_i)$, and $\tree{\Gamma}_2^i(\vect{x})$ is the dimension of $\vect{x}_i$ in $\vect{\pi}$. If, for example, the vector $\vect{x}$ is represented as shown in Fig. 3.1\textit{a}, then

$$
  \tree{\Gamma}(\vect{x}) = \begin{pmatrix}
    17 & 2 \\
    19 & 4 \\
    27 & 5 \\
    23 & 1 \\
    32 & 3
  \end{pmatrix}.
$$

\par (TODO: FIGURES 3.1 AND 3.2)

\par Any structured operand can first be reduced to an equivalent vector, and the grid matrix therefore suffices for describing the representation of any construct, providing only that the representation of each of its elements is solid. Thus a matrix $\mat{X}$ may be represented by either the row-by-row list $\vect{r} = \mat{E}/\mat{X}$ or the column-by-column list $\vect{c} = \mat{E}/\!/\mat{X}$, and a tree $\tree{T}$ may be represented by the left list matrix $[\tree{T}$ or the right list matrix $]\tree{T}$, either of which may be represented, in turn, by a vector.

\par If a process involves only a small number of variables, it is practical to make their allocation implicit in the algorithm, i.e., to incorporate in the algorithm the selection operations on the vector $\vect{\pi}$ necessary to extract the appropriate variables. This is the procedure usually employed, for example, in simple computer programs. In processes involving numerous variables, implicit allocation may become too cumbersome and confusing, and more systematic procedures are needed.

\subsection*{Linear representations}

\par The representation of a structured operand is said to be \textit{linear} if each component is represented by an infix of the form $(l ↓ \vect{⍺}^d)/\vect{\pi}$, where $l$ is a linear function of the indices of the component. For example, the representation of the matrix $\mat{X}$ indicated by Fig. 3.2 is linear, with $d = 2$ and $l = -11 + 5i + 8j$.

\par A linear representation is solid and can clearly be characterized by a small number of parameters---the dimension $d$ of each component and the coefficients in the linear expression $l$. The representation of a vector $\vect{x}$ is linear if and only if $\tree{\Gamma}_2(\vect{x}) = d\symbfup{\epsilon}$ and the difference $\delta = \tree{\Gamma}_1^i(\vect{x}) - \tree{\Gamma}_1^{i-1}(\vect{x})$ is constant for $i = 2, 3, ..., \nu(\vect{x})$.

\par If $l = p + qi + rj$ is the function defining a linear representation of a matrix $\vect{x}$ and if $a$ is the leading address of a given element, then the leading address of the succeeding element in the row (or column) is simply $a + r$ (or $a + q$). Frequently, the succession must be cyclic, and the resulting sum must be reduced modulo $\nu(\vect{x}) \times r$ (or $\mu(\vect{x}) \times q$). The inherent convenience of linear representations is further enhanced by index registers, which provide efficient incrementation and comparison of addresses.

\par Linear representation of a structured operand requires that all components be of the same dimension in $\vect{\pi}$. This common dimension may, however, be achieved by appending null elements to the shorter components. The convenience of the linear representation must then be weighed against the waste occasioned by the null elements. Moreover, if several vectors or matrices are to be represented and if each is of unspecified total dimension in $\vect{\pi}$, it may be impossible to allot to each an infix sufficiently large to permit linear representation. Consequently, a linear representation is not always practicable.

\subsection*{Nonlinear representations}

\par Since the use of the grid matrix imposes only the condition of solidity for each component, it permits an allocation which is sufficiently general for most purposes. The grid matrix serves in two distinct capacities: (1) as a useful conceptual device for describing an allocation even when the actual allocation is implicit in the program, and (2) as a parameter which enters directly into an algorithm and explicitly specifies the allocation.

\par If the grid matrix is used in a program as an explicit specification of the allocation, then the grid matrix must itself be represented by the physical vector. There remains, therefore, the problem of choosing a suitable allocation for the grid matrix itself; a linear allocation is illustrated by Fig. 3.1\textit{b}.

\par If the grid matrix $\tree{\Gamma}(\vect{x})$ itself employs a linear representation, its use offers advantages over the direct use of a linear representation of $\vect{x}$ only if the total dimension of $\tree{\Gamma}$ in $\vect{\pi}$ is much less than the total dimension of $\vect{x}$ in $\vect{\pi}$ when linear representations are employed for both. This is frequently the case, since each element of a grid matrix belongs to the index set of $\vect{\pi}$ (that is, to $\vect{⍳}^0(\nu(\vect{\pi}))$), and the dimension of each element in $\vect{\pi}$ is therefore both uniform and relatively small. Program 3.3 shows the use of the grid matrix $\tree{\Gamma}(\vect{x})$ and the encoding matrix $\mat{C}$ in determining the $k$th component of the vector $\vect{x}$.

\par (TODO: PROGRAM 3.3 (see html))

\par \textbf{Program 3.3} Determination of $\vect{z} = \vect{⍴}(\vect{x}_k)$ and $z = \vect{x}_k$ from a linear representation of the grid matrix $\tree{\Gamma}(\vect{x})$

\par \textbf{Program 3.3}. A linear representation is assumed for $\tree{\Gamma}(\vect{x})$, with element $\tree{\Gamma}_j^i(\vect{x})$ represented by the infix $((p + qi + rj) ↓ \mathbf{⍺}^g)/\vect{\pi}$. Moreover, each element of $\tree{\Gamma}(\vect{x})$ is assumed to be represented in a base $\vect{b}$ number system. Step 1 determines the leading address of the representation of $\tree{\Gamma}_1^k(\vect{x})$. Step 2 specifies $f$ as the base $\vect{b}$ value of this representation, i.e., as the leading address of $\vect{⍴}(\vect{x}_k)$. Steps 3 and 4 specify $d$ as the dimension of $\vect{x}_k$ in $\vect{\pi}$, and step 5 therefore specifies $\vect{z}$ as the representation of $\vect{x}_k$.

\par Steps 7--9 perform the decoding of $\vect{z} = \vect{⍴}(\vect{x}_k)$ to obtain $\vect{z}$ as the actual value of $\vect{x}_k$. Since this process is normally performed by human or mechanical means (e.g., a printer) outside the purview of the programmer, it is here expressed directly in terms of the encoding matrix $\mat{C}$ rather than in terms of its representation. The left-pointing exit on step 7 is followed only if $\vect{z}$ does not occur as an entry in the encoding matrix.

\par The form chosen for the grid matrix is one of several possible. The two columns could, for example, represent the leading and final addresses of the corresponding representations or the dimensions and final addresses. The present choice of leading address $f$ and dimension $d$ is, however, the most convenient for use in conjunction with the notation adopted for infixes; the logical vector ($f ↓ \mathbf{⍺}^d$) selects the appropriate infix.
